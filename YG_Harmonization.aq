{"config":{"title":"My Workflow","description":"A workflow that does x, y and z","copyright":"My Organization","version":"0.0.1","authors":[{"name":"First Last","affiliation":"A Place"}],"maintainer":{"name":"Cannon Mallory","email":"malloc3@uw.edu"},"acknowledgements":[{"name":"First Last","affiliation":"A Place"}],"github":{"user":"malloc3","repo":"YG_Harmonization"},"keywords":null,"aquadoc_version":"1.0.2","aquarium_version":"\u003c%= Bioturk::Application.config.aquarium_version %\u003e","export_title":""},"components":[{"library":{"name":"BiotekPlateReaderCalibration","category":"YG_Harmonization","code_source":"needs 'Standard Libs/MatrixTools'\nneeds 'YG_Harmonization/PlateReaderMethods'\n# This module is used for doing the extraction and calculations required to\n# successfully calibrate the Biotek Plate reader\n#\nmodule BiotekPlateReaderCalibration\n    include PlateReaderMethods\n    include MatrixTools\n    require 'csv'\n    require 'open-uri'\n\n    CAL_TEMPLATE_FILENAME = \"calibration_template_v1\"\n    CAL_MEASUREMENTS = ['cal_od', 'cal_gfp']\n\n  # Takes in a csv upload file, extracts the information on it\n  # into a datamatrix object which is returned.\n  # Specificly tuned to the output file of the biotek plate reader.\n  #\n  # @param upload [Upload]  the object which can be resolved to calibration csv\n  # @return [WellMatrix]  a WellMatrix holding the measurement for each well\n  def extract_measurement_matrix_from_csv(upload)\n    url = upload.url\n    table = []\n    CSV.new(open(url)).each { |line| table.push(line) }\n    dm = WellMatrix.create_empty(96, 'NA') if table.size \u003e 25\n    dm = WellMatrix.create_empty(24, 'NA') if table.size \u003c= 25\n    table.each_with_index do |row, idx|\n      next if idx.zero?\n      well_coord = row[2]\n      next if well_coord.nil?\n      measurement = row[3].to_f\n      next if measurement.nil?\n      dm.set(well_coord, measurement)\n    end\n    dm\n  end\n\n    # Returns the average OD measurement for different dilutions and well volumes.\n    # The plotted result of this method can be fit to a curve\n    # to be used for calibrating the plate reader. This is very specific to the\n    # Eriberto's calibration of the biotek plate reader.\n    #\n    # @param upload [Upload]  the object whihc can be resolved to calibration csv\n    # @return [Hash]  a hash containing averaged measurements for every concentration and volume tested\n    def get_calibration_data_hash(upload)\n        method = upload.name\n        dm = extract_measurement_matrix_from_csv(upload)\n        result = {}\n        data_by_conc = Hash.new { |h, key| h[key] = [0, 0] }\n\n        if method.include? 'gfp'\n            show {note \"#{method}\"}\n            starting_concentration = 50.0#uM\n            # first 4 rows are serial dilutions\n            for i in 0...4\n              12.times do |j|\n                # each column is a 2x dilution of the previous, starting at 50uM\n                this_conc = starting_concentration / (2**j)\n                data = data_by_conc[this_conc]\n                data[0] += dm[i, j].to_f\n                data[1] += 1\n                data_by_conc[this_conc] = data\n              end\n            end\n            # add serial dilution averages to result hash\n            data_by_conc.each_key do |k,|\n              data = data_by_conc[k]\n              result[k] = data[0] / data[1]\n            end\n            return result\n        elsif method.include? 'od'\n            # row 5, 6 are lud dilutions and pure solution respectively\n            for i in 4...6\n                for j in 0...4\n                    data_by_conc[\"100_#{i}\"][0] += dm[i, j].to_f\n                    data_by_conc[\"100_#{i}\"][1] += 1\n                end\n                for j in 4...8\n                    data_by_conc[\"200_#{i}\"][0] += dm[i, j].to_f\n                    data_by_conc[\"200_#{i}\"][1] += 1\n                end\n                for j in 8...12\n                    data_by_conc[\"300_#{i}\"][0] += dm[i, j].to_f\n                    data_by_conc[\"300_#{i}\"][1] += 1\n                end\n            end\n            # add lud averages to result hash\n            for i in 1..3\n              lud_avg = data_by_conc[\"#{i}00_4\"][0] / data_by_conc[\"#{i}00_4\"][1]\n              sol_avg = data_by_conc[\"#{i}00_5\"][0] / data_by_conc[\"#{i}00_5\"][1]\n              result[\"lud#{i}00\"] = (lud_avg - sol_avg).round(5) # Returns blanked averages\n            end\n        end\n        result\n    end\n  \n  #-------------Plate ReaderCalibration------------------------------------------------------------#\n    # Finds the first \n    def check_cal_plate_date()\n        \n        create_a_new_cal_plt = false\n        calibration_plate = nil # if the plate is less than a month old use the cal plate\n        \n        # Look through flat bottom plates and see which one has flourescein inside\n        flour_samp = Sample.find_by_name(\"Fluorescein Sodium Salt\" )\n        test_plts = find(:item,{object_type: { name: \"96 Well Flat Bottom (black)\" }} ).select {|i| i.location != 'deleted'}\n        \n        # Check to see if there is a calibration plate that is less than a month old\n        test_plts.each do |item_id|\n            mat = Collection.find(item_id).matrix.flatten.uniq\n            if mat.include? flour_samp.id\n                date_created = Item.find(item_id).get('date_created')\n                \n                present = todays_date()\n                \n                plus_month = [date_created[0..1], date_created[2..3], date_created[4..7]].map {|i| i.to_i}\n                plus_month[0] = plus_month[0] + 1\n                \n                date_created = [date_created[0..1], date_created[2..3], date_created[4..7]].map {|i| i.to_i}\n                \n                today = [present[0..1], present[2..3], present[4..7]].map {|i| i.to_i}\n                \n                # log_info 'CALIBRATION PLATE AGE','date_created', date_created, 'plus_month', plus_month, 'todays_date', today\n                \n                if date_created[0] == plus_month[0] # Checking month\n                    if plus_month[1] \u003e= date_created[1] # Checking day\n                        create_a_new_cal_plt = true\n                        Item.find(item_id).mark_as_deleted\n                    else\n                        calibration_plate = item_id\n                    end\n                else\n                    calibration_plate = item_id\n                end\n            end\n        end\n        return create_a_new_cal_plt, calibration_plate\n    end\n\n\n    \n    \n    # Creates a calibration plate for the plate reader with a Fluorescein dye and an optical density reagent\n    #\n    # @params flour [string] \n    # @params ludox [string]\n    # @params collection [collection obj] container of plate reader cal solutions\n    def create_cal_plate(cal_coll)\n        flour_samp = Sample.find_by_name(\"Fluorescein Sodium Salt\" )\n        ludox_samp = Sample.find_by_name(\"LUDOX Stock\")\n        \n        # Items and materials required for calibration plate\n        flour_item = find(:item, { sample: { name: flour_samp.name }, object_type: { name: \"1mM Fluorescein Stock\" } } ).first\n        ludox_item = find(:item, { sample: { name: ludox_samp.name }, object_type: { name: \"1X LUDOX Aliquot\" } } ).first\n        cal_items = [flour_item, ludox_item]\n        \n        take cal_items, interactive: true\n        \n        h2o_type = \"Nuclease-free water\" # Change in Production Aq to Mol grade H2O\n        h2o_samp = Sample.find_by_name(h2o_type) \n        cal_plt_mats = {'1X PBS'=\u003e'Bench', 'Mol. Grade H2O'=\u003e'Media Bay', '96 Well Flat Bottom (black)'=\u003e'Bench'}\n        \n        show do\n            title \"Creating a New Calibration Plate\"\n            separator\n            note \"\u003cb\u003eGather the following:\u003c/b\u003e\"\n            cal_plt_mats.each {|mat, loc| check \"#{mat} at #{loc}\"}\n        end\n        \n        show do\n            title \"Creating a New Calibration Plate\"\n            separator\n            note \"Vortex 1mM Fluorescein Stock and make sure there are no precipitates.\"\n            check \"In a fresh 1.5mL Eppendorf tube, dilute 50µl of 1mM Fluorescein Stock into 950µl of 1X PBS - Final Concentration [50µM]\"\n            note \"Make sure to vortex.\"\n        end\n        \n        dims = cal_coll.dimensions\n        rows = dims[0]\n        cols = dims[1]\n        new_coll_mat = Array.new(rows) { Array.new(cols) { -1 } }\n        rows.times do |r|\n           cols.times do |c|\n                if r \u003c 4\n                   new_coll_mat[r][c] = flour_samp.id \n                elsif r == 4\n                   new_coll_mat[r][c] = ludox_samp.id\n                elsif r == 5\n                    new_coll_mat[r][c] = h2o_samp.id\n                end\n            end\n        end\n        cal_plate = cal_coll\n        cal_plate.matrix = new_coll_mat\n        cal_plate.save\n        \n        # selects wells that have flourescin sample id, then selects for the one's that are not in the first column of the collection is an array of [r,c]\n        pbs_wells = cal_plate.select {|well| well == flour_samp.id}.select {|r, c| c != 0}\n        \n        # direct tech to fill new calibration plate\n        show do\n            title \"Creating a New Calibration Plate\"\n            separator\n            note \"You will need \u003cb\u003e#{(pbs_wells.length * 0.1) + 0.1}mL\u003c/b\u003e of 1X PBS for the next step.\"\n            note \"Follow the table below to dispense 1X PBS in the appropriate wells:\"\n            table highlight_rc(cal_plate, pbs_wells) {|r,c| \"100µl\"}\n        end\n        \n        flour_serial_image = \"Actions/Yeast_Gates/plateReaderImages/flour_serial_dilution.png\"\n        show do\n            title \"Serial Dilution of Flourescein\"\n            separator\n            note \"From the 50µM Fluorescein solution, dispense \u003cb\u003e200µl\u003c/b\u003e in wells \u003cb\u003eA1, B1, C1, D1\u003c/b\u003e\"\n            note \"Following the image below, transfer \u003cb\u003e100µl\u003c/b\u003e of 50µM Fluorescein solution in Column 1 to Column 2\"\n            note \"Resuspend by pipetting up and down 3X\"\n            note \"Repeat until column 11 and discard the remaining \u003cb\u003e100µl\u003c/b\u003e.\"\n            image flour_serial_image\n        end\n        \n        # selects wells of a collection that have the ludox sample id, collects them as an array of [r, c]\n        ludox_wells = cal_plate.select {|well| well == ludox_samp.id}\n        \n        show do\n            title \"Creating a New Calibration Plate\"\n            separator\n            note \"Follow the table below to dispense #{ludox_samp.name} into the appropriate wells.\"\n            table highlight_rc(cal_plate, ludox_wells) {|r,c| ludox_vol(r, c)}\n        end\n        \n        # selects wells of a collection that have the MG H2O sample id, collects them as an array of [r, c]\n        h2o_wells = cal_plate.select {|well| well == h2o_samp.id}\n        \n        show do\n            title \"Creating a New Calibration Plate\"\n            separator\n            note \"Follow the table below to dispense #{h2o_type} into the appropriate wells.\"\n            table highlight_rc(cal_plate, h2o_wells) {|r,c| ludox_vol(r, c)}\n        end\n        # Assocaite todays_date with item\n        Item.find(cal_plate.id).associate('date_created', todays_date)\n        release cal_items, interactive: true\n        return cal_plate\n    end\n    \n    def ludox_vol(row, col)\n        if col \u003c 4\n            return \"100µl\"\n        elsif col.between?(4, 7)\n            return \"200µl\"\n        else col.between?(7, 11)\n            return \"300µl\"\n        end\n    end\n    \n    # This function directs tech to measure calibration plate on plate reader and export data; it also associates data from plate reader\n    #\n    # @params cal_plates [Array] an array of item objects\n    #\n    def measure_cal_plate(cal_plate)\n        # measure on plate reader \n        set_up_plate_reader(cal_plate, CAL_TEMPLATE_FILENAME)\n        \n        # Export a file for each measurement\n        CAL_MEASUREMENTS.each do |method|\n            \n            timepoint = nil # Is nil since it is not being measured along with this experiment\n            filename = export_data(cal_plate, timepoint, method=method)\n            \n            # Show block upload button and retrieval of file uploaded\n            up_show, up_sym = upload_show(filename)\n            if (up_show[up_sym].nil?)\n                show {warning \"No upload found for calibration measurement. Try again!!!\"}\n                up_show, up_sym = upload_show(filename)\n            else\n                upload = find_upload_from_show(up_show, up_sym)\n                key = \"#{todays_date}_#{method}\"\n                \n                # Associates upload to calibration plate and plan\n                associate_to_plans(key, upload)\n                associate_to_item(cal_plate, key, upload)\n                # Associates data hash of measurements to item/collection - extract info from plate reader upload and associate with item\n                associate_PlateReader_Data(upload, cal_plate, method, timepoint)\n            end\n        end\n        cal_plate.location = '4°C Fridge'\n        # cal_plate.mark_as_deleted\n    end\n#-------------------------------------------------PlateReaderControl-----------------------------------------------------#\n  \n  \n  \n  \n  \nend #module"}},{"library":{"name":"HighThroughput_Lib","category":"YG_Harmonization","code_source":"# By: Eriberto Lopez\n# elopez3@uw.edu\n\n# This library contains functions that aid in yeast high throughput screening.\n# Ie: Calculations, formatting collections, etc...\n\n\nneeds \"Standard Libs/AssociationManagement\"\nneeds \"Standard Libs/MatrixTools\"\n\nmodule HighThroughput_Lib\n    include AssociationManagement, MatrixTools\n    include PartProvenance\n    \n    # Finds where an alpha_coordinate is in a 96 Well plate\n    #\n    # @params alpha_coord [array or string] can be a single alpha_coordinate or a list of alpha_coordinate strings ie: 'A1' or ['A1','H7']\n    # @return rc_list [Array] a list of [r,c] coordinates that describe where the alpha_coord(s) are in a 96 well matrix\n    def find_rc_from_alpha_coord(alpha_coord)\n        # look for where alpha coord is 2-D array coord\n        coordinates_96 = ('a'..'h').to_a.map {|row| (1..12).to_a.map {|col| row + col.to_s}} \n        rc_list = []\n        if alpha_coord.instance_of? Array\n            alpha_coord = alpha_coord.map {|a| a.downcase}\n            alpha_coord.each {|a_coord|\n                coordinates_96.map.each_with_index { |row, r_idx| row.each_index.select {|col| row[col] == a_coord}.each { |c_idx| rc_list.push([r_idx, c_idx]) } } \n            }\n        else\n            coordinates_96.map.each_with_index { |row, r_idx| row.each_index.select {|col| row[col] == alpha_coord.downcase}.each { |c_idx| rc_list.push([r_idx, c_idx]) } }\n        end\n        return rc_list\n    end\n    \n    # Fills collection matrix with sample_ids based on how many biological replicates requested\n    #\n    # @params collection [collection] collection to be filled with biological replicates\n    # @params items [array] an array of items that biological replicates will be taken from\n    # @params bio_reps [integer] comes from protocol parameter altered to an integer \n    # @return collection [collection] filled collection with same dimensions\n    def fill_collection_mat(collection, items, bio_reps)\n      items.each do |item|\n        colony_num = 0\n        item_associations = AssociationMap.new(item)\n        bio_reps.times do\n          r, c, x = collection.add_one(item.sample_id)\n          part = collection.part(r, c)\n          part_associations = AssociationMap.new(part)\n\n          # record historical relation between item and target collection part, using PartProvenance\n          add_provenance({\n                           from: item,\n                           from_map: item_associations,\n                           to: part,\n                           to_map: part_associations,\n                           additional_relation_data: { source_colony: colony_num, process: \"resuspension\" }\n                         })\n          part_associations.save\n          colony_num += 1\n        end\n        item_associations.save\n      end\n      return collection\n    end\n    \n    def alpha_coords_96_matrix()\n        ('a'..'h').to_a.map {|row| (1..12).to_a.map {|col| row + col.to_s}}\n    end\n    \n    # Empty collection matrix\n    #\n    # @params collection [collection] collection you wish to empty\n    # @return collection [collection] emptied collection with same dimensions\n    def blank_collection_mat(collection)\n        # empty out_coll\n        rc_list = collection.get_non_empty\n        rc_list.map {|r,c| collection.set(r,c,-1)}\n        return collection\n    end\n\n\nend # Module\n\n"}},{"library":{"name":"PlateReaderMethods","category":"YG_Harmonization","code_source":"# By: Eriberto Lopez\n# elopez3@uw.edu\n\n\nneeds \"Yeast Display/YeastDisplayHelper\"\nneeds \"Tissue Culture Libs/CollectionDisplay\"\nneeds 'Standard Libs/AssociationManagement'\n\nneeds \"YG_Harmonization/Upload_PlateReader_Data\"\n\n# needs \"YG_Harmonization/BiotekPlateReaderCalibration\"\n\nmodule PlateReaderMethods\n    \n    include YeastDisplayHelper\n    include CollectionDisplay\n    include Upload_PlateReader_Data\n    # include BiotekPlateReaderCalibration\n    include AssociationManagement\n    \n    SAVING_DIRECTORY = \"_UWBIOFAB\"\n    # Experimental Default volume\n    DEFAULT_VOLUME = { qty: 300, units: 'µl' }\n    PLT_READER_LOC = \"A10.530\"\n    PLT_READER_TYPE = 'Biotek Synergy HT'\n    # Plate Reader Calibration\n    CAL_TEMPLATE_FILENAME = \"calibration_template_v1\"\n    CAL_MEASUREMENTS = ['cal_od', 'cal_gfp']\n\n    # Directs technician to set up biotek plate reader software\n    #\n    # @params collection [collection obj] the collection that is being measured\n    # @params template_filename [string] the name of the biotek protcol/measurement template\n    def set_up_plate_reader(collection, template_filename)\n        if template_filename.include? 'calibration_template'\n            experiment_filename = \"experiment_calibration_plate_#{todays_date}\"\n        else\n            experiment_filename = \"experiment_#{collection.id}_#{todays_date}\"\n        end\n        # Open Biotek software\n        # Set up plate reader workspace and taking measurements\n        # select new exp and save\n        img1 = \"Actions/Yeast_Gates/plateReaderImages/open_biotek.PNG\"\n        img2 = \"Actions/Yeast_Gates/plateReaderImages/begin_plate_reader.PNG\"\n        \n        show do\n            title \"Setting Up Plate Reader Workspace\"\n            separator\n            note \"\u003cb\u003eThe next steps should be done on the plate reader computer\u003c/b\u003e.\"\n            note \"\u003cb\u003e1.\u003c/b\u003e Open BioTek Gen5 software by clicking the icon shown below.\"\n            image img1\n            note \"\u003cb\u003e2.\u003c/b\u003e Under \u003cb\u003e'Create a New Item'\u003c/b\u003e click \u003cb\u003e'Experiment'\u003c/b\u003e \"\n            # select template\n            note \"\u003cb\u003e3.\u003c/b\u003e From the list select: \u003cb\u003e#{template_filename}\u003c/b\u003e\"\n            note \"\u003cb\u003e4.\u003c/b\u003e Click Read Plate icon shown below\"\n            image img2\n            note \"\u003cb\u003e5.\u003c/b\u003e Click \u003cb\u003e'READ'\u003c/b\u003e on the pop-up window.\"\n            bullet \"Name experiment file: \u003cb\u003e#{experiment_filename}\u003c/b\u003e\"\n            bullet \"\u003cb\u003eSave\u003c/b\u003e it under the \u003cb\u003e#{SAVING_DIRECTORY}\u003c/b\u003e folder.\"\n            note \"\u003cb\u003e6.\u003c/b\u003e Load plate and click \u003cb\u003e'OK'\u003c/b\u003e\"\n        end\n\n        # show do\n        #     title \"Setting Up Plate Reader Workspace\"\n            \n        #     note \"Take 96 well plate to the plate reader computer, under cabinet \u003cb\u003e#{PLT_READER_LOC}\u003c/b\u003e.\"\n        #     note \"Open BioTek Gen5 software by clicking the icon shown below.\"\n        #     image img1\n        #     note \"Under 'Create a New Item' click \u003cb\u003e'Experiment'\u003c/b\u003e \"\n        #     # select template\n        #     note \"From the list select \u003cb\u003e#{template_filename}\u003c/b\u003e\"\n        #     note \"Next, click Read Plate icon shown below and click \u003cb\u003e'READ'\u003c/b\u003e on the pop-up window.\"\n        #     image img2\n        #     note \"Name experiment file: \u003cb\u003e#{experiment_filename}\u003c/b\u003e\"\n        #     note \"Finally, save it under the \u003cb\u003e#{SAVING_DIRECTORY}\u003c/b\u003e folder.\"\n        #     note \"Load plate and click \u003cb\u003e'OK'\u003c/b\u003e\"\n        # end\n    end\n        \n    \n    def add_blanks(volume={}, media)\n        volume = DEFAULT_VOLUME unless volume.present?\n        \n        show do\n            title \"Add Blanks to Plate\"\n            \n            note \"Prior to our measurement, we must add a blank to get a true OD reading.\"\n            check \"Fill the last three wells of the 96 Well plate \u003cb\u003eH10, H11, H12\u003c/b\u003e with #{qty_display(volume)} of \u003cb\u003e#{media}\u003c/b\u003e liquid media.\"\n        end\n    end\n    \n    def load_plate\n        show do\n            title \"Load Plate Reader\"\n            \n            note \"Load plate on to the plate reader and click \u003cb\u003e'OK'\u003c/b\u003e\"\n        end\n    end\n    \n    # Exports data from plate reader (BioTek Gen 5)\n    #\n    # @params collection [collection obj] collection that is being measured\n    # @params timepoint [integer] what hour into the experiment is this data being collected\n    # @params method [string] what is being measured on the plate reader can also be gfp\n    # @return filename [string] filename generated with information for downstream processing\n    def export_data(collection, timepoint, method='od')\n        if method.include? 'cal'\n            filename = \"jid_#{jid}_item_#{collection.id}_#{todays_date}_#{method}\"\n        else\n            filename = \"jid_#{jid}_item_#{collection.id}_#{timepoint}hr_#{todays_date}_#{method}\"\n        end\n        \n        img1 = \"Actions/Yeast_Gates/plateReaderImages/exporting_data_new.GIF\"\n        img2 = \"Actions/Yeast_Gates/plateReaderImages/excel_export_button_new.png\"\n        img3 = \"Actions/Yeast_Gates/plateReaderImages/saving_export_csv_new.png\"\n        \n        case method\n        when 'od'\n            dtype = 'Blank Read 1:600'\n            desc = 'Optical Density'\n        when 'gfp'\n            dtype = 'Blank Read 2:485/20,516/20'\n            desc = 'Fluorescence'\n        when 'cal_od'\n            dtype = 'Read 1:600'\n            desc = 'Calibration Optical Density'\n        when 'cal_gfp'\n            dtype = 'Read 2:485/20,516/20'\n            desc = 'Calibration Fluorescence'\n        else\n            dtype = ''\n        end\n        \n        # Exporting single file (csv)\n        show do\n            title \"Export #{desc} Measurements from Plate Reader\"\n            warning \"Make sure that no other Excel sheets are open before exporting!\"\n            separator\n            image img1\n            bullet \"Select the \u003cb\u003e'Statistics'\u003c/b\u003e tab\"\n            bullet \"Select Data: \u003cb\u003e#{dtype}\u003c/b\u003e\"\n            separator\n            note \"Next, click the Excel sheet export button. \u003cb\u003eThe sheet will appear on the menu bar below\u003c/b\u003e.\"\n            image img2\n            warning \"Make sure to save file as a .CSV file!\"\n            note \"Go to sheet and \u003cb\u003e'Save as'\u003c/b\u003e ==\u003e \u003cb\u003e#{filename}\u003c/b\u003e under the \u003cb\u003e#{SAVING_DIRECTORY}\u003c/b\u003e folder.\"\n            image img3\n        end\n\n        # show do\n        #     title \"Export #{desc} Measurements from Plate Reader\"\n            \n        #     warning \"Make sure that no other Excel sheets are open before exporting!\"\n        #     separator\n        #     note \"After measurements have been taken, be sure to select the \u003cb\u003e'Statistics'\u003c/b\u003e tab\"\n        #     note \"Select Data: \u003cb\u003e#{dtype}\u003c/b\u003e\"\n        #     image img1\n        #     note \"Next, click the Excel sheet export button. The sheet will appear on the menu bar below.\"\n        #     image img2\n        #     note \"Go to sheet and 'Save as' \u003cb\u003e#{filename}\u003c/b\u003e under the \u003cb\u003e#{SAVING_DIRECTORY}\u003c/b\u003e folder.\"\n        #     warning \"Make sure to save file as a .CSV file!\"\n        #     image img3\n        # end\n        \n        return filename\n    end\n    \n    def todays_date\n        DateTime.now.strftime(\"%m%d%Y\")\n    end\n    \n    # Give an introduction to the sync by OD protocol\n    #\n    # @param wavelength [integer] the type of light measured, 0 to 900\n    def intro_sync_OD(wavelength)\n        show do\n            title \"Sychronization of Cultures by OD\"\n            \n            note \"In this protocol you will be measuring the cell concentration of cultures by Optical Density.\"\n            note \"Then we will normalize all cultures to a similar cellular concentration to begin our growth experiment.\"\n            note \"This allows researchers to observe discrepencies in growth rates of different strains and allows us to compare conditions.\"\n            note \"\u003cb\u003e1.\u003c/b\u003e Setup Plate Reader (Biotek) \u0026 measure OD#{wavelength}.\"\n            note \"\u003cb\u003e2.\u003c/b\u003e Take a calculated volume from each well and dilute into a 96 Deep Well Plate.\"\n        end\n    end\n    \n    # Associates the actual ODs calculated from the well OD and the ave culture volume diluted into the final vol\n    #\n    # @params out_coll [collection obj] output collection that the od_mat will be associated to \n    # @params od_mat [2-D Array] matrix containing ODs of the output collection\n    def associate_true_ods_item(out_coll,od_mat)\n        timepoint = 0 # timepoint now at t = 0 since we have diluted our cultures to the necessary starting ODs\n        k = 'optical_density'\n        method = 'od'\n        od_hsh = Hash.new(0)\n        od_hsh[\"#{timepoint}_hr_#{method}\"] = od_mat\n        Item.find(out_coll.id).associate(k, od_hsh)\n    end\n    # # This function directs tech to pre-fill deep well plate with required media\n    # #\n    # # @params out_coll [collection obj] the output collection object\n    # # @params type_of_media [string] describes the type of media to be used in the experiment\n    # # @params media_vol_mat [2-D Array] is a matrix of the media volume per well in ul \n    # def aliquot_media(out_coll, media_vol_mat, media)\n    #     # Direct tech to fill output plate with media\n    #     tot_media_vol = 0\n    #     media_vol_mat.flatten.each {|vol| tot_media_vol += vol}\n        \n    #     # Where controls are to be placed in the experimental plate\n    #     gfp_input_cult_coord = 'H9'\n    #     wt_no_stain_coord = 'H7'\n    #     wt_stain_coord = 'H8'\n        \n    #     rc_list = out_coll.get_non_empty\n    #     rc_list.push(find_rc_from_alpha_coord(alpha_coord=gfp_input_cult_coord).first)\n    #     rc_list.push(find_rc_from_alpha_coord(alpha_coord=wt_no_stain_coord).first)\n    #     rc_list.push(find_rc_from_alpha_coord(alpha_coord=wt_stain_coord).first)\n    #     log_info 'rc_list', rc_list\n    #     show do\n    #         title \"Filling New 96 Deep Well Plate #{out_coll}\"\n            \n    #         note \"For this step you will need:\"\n    #         check \"96 Well Deep U-bottom Plate and label with \u003cb\u003e#{out_coll.id}\u003c/b\u003e\"\n    #         check \"Multichannel Reservoir\"\n    #         check \"Breathable AeraSeal Plate Cover\"\n    #         check \"\u003cb\u003e#{((tot_media_vol/1000) + 1).round(1)} mLs\u003c/b\u003e of \u003cb\u003e#{media}\u003c/b\u003e liquid growth media.\"\n    #     end\n    #     show do\n    #         title \"Filling 96 Deep Well Plate #{out_coll}\"\n    #         note \"Follow the table bellow to aliquot the appropriate amount of \u003cb\u003e#{media}\u003c/b\u003e media to the respective well:\"\n    #         table highlight_rc(out_coll, rc_list) { |r, c| \"#{(media_vol_mat[r][c]).round(1)} µl\" }\n    #     end\n    # end\n    \n# -------------------------------------------------PlateReaderControl------------------------------------------------------------------#\n    # def calibration_plate_chk()\n    #     # is plate made already?\n    #     check_cal_plate = show do\n    #         title \"Calibrating the #{PLT_READER_TYPE} Plate Reader\"\n    #         separator\n    #         select [ \"Yes\", \"No\"], var: \"cal_plate\", label: \"Is there a calibration plate that is less than 2 weeks old? If not, select 'No' and proceed to the next step.\"\n    #         # note \"If yes, take the calibration plate and place on the plate shaker in the 30°C incubator for 5 mins.\"\n    #     end\n    #     return (check_cal_plate[:cal_plate] == \"No\" ? false : true)\n    # end\n    \n    # # Creates a calibration plate for the plate reader with a flourescence dye and a optical density reagent\n    # #\n    # # @params flour [string] \n    # # @params ludox [string]\n    # # @params collection [collection obj] container of plate reader cal solutions\n    # def create_cal_plate(cal_coll)\n    #     flour_samp = Sample.find_by_name(\"Fluorescein Sodium Salt\" )\n    #     ludox_samp = Sample.find_by_name(\"LUDOX Stock\")\n        \n    #     # Items and materials required for calibration plate\n    #     flour_item = find(:item, { sample: { name: flour_samp.name }, object_type: { name: \"1mM Fluorescein Stock\" } } ).first\n    #     ludox_item = find(:item, { sample: { name: ludox_samp.name }, object_type: { name: \"1X LUDOX Aliquot\" } } ).first\n    #     cal_items = [flour_item, ludox_item]\n    #     take cal_items, interactive: true\n    #     h2o_type = \"Nuclease-free water\" # Change in Production Aq to Mol grade H2O\n    #     h2o_samp = Sample.find_by_name(h2o_type) \n    #     cal_plt_mats = {'1X PBS'=\u003e'Bench', 'Mol. Grade H2O'=\u003e'Media Bay', '96 Well Flat Bottom (black)'=\u003e'Bench'}\n        \n    #     show do\n    #         title \"Creating a New Calibration Plate\"\n    #         separator\n    #         note \"\u003cb\u003eGather the following:\u003c/b\u003e\"\n    #         cal_plt_mats.each {|mat, loc| check \"#{mat} at #{loc}\"}\n    #     end\n        \n    #     show do\n    #         title \"Creating a New Calibration Plate\"\n    #         separator\n    #         note \"Vortex 1mM Fluorescein Stock and make sure there are no precipitates.\"\n    #         check \"In a fresh 1.5mL Eppendorf tube, dilute 50µl of 1mM Fluorescein Stock into 950µl of 1X PBS - Final Concentration [50µM]\"\n    #         note \"Make sure to vortex.\"\n    #     end\n        \n    #     dims = cal_coll.dimensions\n    #     # log_info 'dims', dims\n    #     rows = dims[0]\n    #     cols = dims[1]\n    #     new_coll_mat = Array.new(rows) { Array.new(cols) { -1 } }\n    #     rows.times do |r|\n    #       cols.times do |c|\n    #             if r \u003c 4\n    #               new_coll_mat[r][c] = flour_samp.id \n    #             elsif r == 4\n    #               new_coll_mat[r][c] = ludox_samp.id\n    #             elsif r == 5\n    #                 new_coll_mat[r][c] = h2o_samp.id\n    #             end\n    #         end\n    #     end\n    #     cal_plate = cal_coll\n    #     cal_plate.matrix = new_coll_mat\n    #     cal_plate.save\n    #     # log_info 'new_coll_mat', new_coll_mat\n    #     # log_info 'cal_plate matrix', cal_plate.matrix\n        \n    #     pbs_wells = cal_plate.select {|well| well == flour_samp.id}.select {|r, c| c != 0}\n        \n    #     # direct tech to fill new calibration plate\n    #     show do\n    #         title \"Creating a New Calibration Plate\"\n    #         separator\n    #         note \"You will need \u003cb\u003e#{(pbs_wells.length * 0.1) + 0.1}mL\u003c/b\u003e of 1X PBS for the next step.\"\n    #         note \"Follow the table below to dispense 1X PBS in the appropriate wells:\"\n    #         table highlight_rc(cal_plate, pbs_wells) {|r,c| \"100µl\"}\n    #     end\n        \n    #     flour_serial_image = \"Actions/Yeast_Gates/plateReaderImages/flour_serial_dilution.png\"\n    #     show do\n    #         title \"Serial Dilution of Flourescein\"\n    #         separator\n    #         note \"From the 50µM Fluorescein solution, dispense \u003cb\u003e200µl\u003c/b\u003e in wells \u003cb\u003eA1, B1, C1, D1\u003c/b\u003e\"\n    #         note \"Following the image below, transfer \u003cb\u003e100µl\u003c/b\u003e of 50µM Fluorescein solution in Column 1 to Column 2\"\n    #         note \"Resuspend by pipetting up and down 3X\"\n    #         note \"Repeat until column 11 and discard the remaining \u003cb\u003e100µl\u003c/b\u003e.\"\n    #         image flour_serial_image\n    #     end\n        \n    #     ludox_wells = cal_plate.select {|well| well == ludox_samp.id}\n        \n    #     show do\n    #         title \"Creating a New Calibration Plate\"\n    #         separator\n    #         note \"Follow the table below to dispense #{ludox_samp.name} into the appropriate wells.\"\n    #         table highlight_rc(cal_plate, ludox_wells) {|r,c| ludox_vol(r, c)}\n    #     end\n        \n    #     h2o_wells = cal_plate.select {|well| well == h2o_samp.id}\n        \n    #     show do\n    #         title \"Creating a New Calibration Plate\"\n    #         separator\n    #         note \"Follow the table below to dispense #{h2o_type} into the appropriate wells.\"\n    #         table highlight_rc(cal_plate, h2o_wells) {|r,c| ludox_vol(r, c)}\n    #     end\n    #     # Assocaite todays_date with item\n    #     Item.find(cal_plate.id).associate('date_created', todays_date)\n    #     release cal_items, interactive: true\n    #     return cal_plate\n    # end\n    \n    # def ludox_vol(row, col)\n    #     if col \u003c 4\n    #         return \"100µl\"\n    #     elsif col.between?(4, 7)\n    #         return \"200µl\"\n    #     else col.between?(7, 11)\n    #         return \"300µl\"\n    #     end\n    # end\n    \n    # # This function directs tech to measure calibration plate on plate reader and export data; it also associates data from plate reader\n    # #\n    # # @params cal_plates [Array] an array of item objects\n    # #\n    # def measure_cal_plate(cal_plates)\n    #     cal_plate = cal_plates.first\n    #     # measure on plate reader \n    #     set_up_plate_reader(cal_plate, CAL_TEMPLATE_FILENAME)\n        \n    #     # Export a file for each measurement - Can the plate Reader export in xml?\n    #     CAL_MEASUREMENTS.each do |method|\n            \n    #         timepoint = nil # Is nil since it is not being measured along with this experiment\n    #         filename = export_data(cal_plate, timepoint, method=method)\n            \n    #         # Show block upload button and retrieval of file uploaded\n    #         up_show, up_sym = upload_show(filename)\n    #         if (up_show[up_sym].nil?)\n    #             show {warning \"No upload found for calibration measurement. Try again!!!\"}\n    #             up_show, up_sym = upload_show(filename)\n    #         else\n    #             upload = find_upload_from_show(up_show, up_sym)\n    #             key = \"#{todays_date}_#{method}\"\n    #             # Need to associate data to all plans that are batched in job\n    #             associate_to_plan(upload, key)\n                \n    #             # Associates upload to calibration plate and plan\n    #             cal_plates.each do |cal_plate|\n    #                 associate_to_item(cal_plate, key, upload)\n    #                 # Associates data hash of measurements to item/collection - extract info from plate reader upload and associate with item\n    #                 associate_PlateReader_Data(upload, cal_plate, method, timepoint)\n    #             end\n    #         end\n    #     end\n    #     cal_plates.shift.location = '4°C Fridge'\n    #     cal_plates.each {|plt| plt.mark_as_deleted}\n    # end\n#-------------------------------------------------PlateReaderControl------------------------------------------------------------------#\n\nend # module"}},{"library":{"name":"SynchronizationLib","category":"YG_Harmonization","code_source":"\n\nmodule SynchronizationLib\n    \n    FINAL_OD = [0.0003, 0.00015, 0.000075]\n    FINAL_OUTPUT_VOL = 1#mL\n    ROWS = ('A'..'H').to_a\n    COLS = (1..12).to_a\n    \n    \n    def sync_experimental_cultures(in_collection, out_collection, input_plate_ods, bio_reps)\n        # Coordinates of wells in input collection that have experimental cultures\n        # input_cult_coords = in_collection.get_non_empty.select {|r,c| r != 7 \u0026\u0026 !in_collection.matrix[r][c].nil?}\n        input_cult_coords = in_collection.get_non_empty.select {|r,c| r != 7}\n        # log_info 'input_cult_coords', input_cult_coords, in_collection.get_non_empty\n        \n        # Create an array of ods from non empty wells\n        input_plate_ods = input_cult_coords.map {|r, c| input_plate_ods[r][c]}\n        # log_info 'input_plate_ods', input_plate_ods\n        \n        # Calculates the average OD by slices of 6 wells - PlateReaderMethods\n        average_ods = average_ods(input_cult_coords, input_plate_ods, bio_reps) # bio_rep well average ODs of plate\n        # log_info 'average ods', average_ods\n        \n        # Calculates volumes from culture and media to obtain necessary final OD \n        ave_cult_vols_ul, ave_media_vols_ul = ave_cult_media_vol(average_ods) # 6 well average vols\n        # log_info 'ave_cult_vols_ul', ave_cult_vols_ul\n        # log_info 'ave_media_vols_ul', ave_media_vols_ul\n        \n        # Creates a matrix based on the length of row averages and number of wells measured - Used to display volumes for tech\n        cult_vol_mat = matrix_mapping(input_plate_ods, ave_cult_vols_ul, bio_reps)\n        media_vol_mat = matrix_mapping(input_plate_ods, ave_media_vols_ul, bio_reps)\n        # log_info 'cult_vol_mat', cult_vol_mat\n        # log_info 'media_vol_mat', media_vol_mat\n        \n        # 4. Calc true ODs based on cult_vol_ul and original ODs\n        # Calculates the actual OD of each well based on the input well/cult OD and the average cult vol used for that row\n        actual_ods_mat = actual_ods(input_plate_ods, ave_cult_vols_ul, bio_reps)\n        # log_info 'actual_ods_mat', actual_ods_mat\n            \n        # 5. Associate new actual ODs to output collection - t = 0\n        associate_true_ods_item(out_collection, actual_ods_mat)\n        \n        out_collection.matrix = out_coll_samp_id_mat(in_collection)\n        \n        \n        return input_cult_coords, cult_vol_mat, media_vol_mat\n    end\n\n    # This function directs tech to pre-fill deep well plate with required media\n    #\n    # @params out_coll [collection obj] the output collection object\n    # @params type_of_media [string] describes the type of media to be used in the experiment\n    # @params media_vol_mat [2-D Array] is a matrix of the media volume per well in ul \n    def aliquot_media(out_coll, media_vol_mat, media)\n        # Direct tech to fill output plate with media\n        tot_media_vol = 0\n        # show do\n        #     title 'media vol mat - aliquot_media()'\n        #     note \"#{media_vol_mat}\"\n        # end\n        media_vol_mat.flatten.select {|vol| vol != -1 }.each {|vol|\n            tot_media_vol += vol if vol\n        }\n        \n        rc_list = out_coll.get_non_empty.select {|r,c| !out_coll.matrix[r][c].nil? }\n        log_info 'rc_list sync lib', rc_list\n        show do\n            title \"Filling New 96 Deep Well Plate #{out_coll}\"\n            separator\n            note \"For this step you will need:\"\n            check \"96 Well Deep U-bottom Plate and label with \u003cb\u003e#{out_coll.id}\u003c/b\u003e\"\n            check \"Multichannel Reservoir\"\n            check \"Breathable AeraSeal Plate Cover\"\n            check \"\u003cb\u003e#{((tot_media_vol/1000) + 1).round(1)}mLs\u003c/b\u003e of \u003cb\u003e#{media}\u003c/b\u003e liquid growth media.\"\n        end\n        show do\n            title \"Filling 96 Deep Well Plate #{out_coll}\"\n            separator\n            note \"Follow the table bellow to aliquot the appropriate amount of \u003cb\u003e#{media}\u003c/b\u003e media to the respective well:\"\n            table highlight_alpha_rc(out_coll, rc_list) { |r, c| \"#{(media_vol_mat[r][c]).round(1) if media_vol_mat[r][c]} µl\" }\n        end\n    end\n    \n    # Directs tech and inoculates output collection with cultures from the input collection\n    #\n    # @param in_coll [collection obj] the input collection\n    # @param out_coll [collection obj] the output collection\n    # @param input_cult_coords [Array] one dimensional array that contains the coordinates of the input collection cultures\n    # @param cult_vol_mat [2-D Array] matrix that contains the volume required to inoculate the output collection\n    def inoculate_plate(in_coll, out_coll, input_cult_coords, cult_vol_mat)\n        # Creates a matrix with row column coordinates from the input collection - Will be used to direct tech which input wells to dilute in the output collection\n        in_out_map = input_cult_coords.map {|r, c| (ROWS[r] + COLS[c].to_s)}.select {|coord| !coord.include? \"H\"} # [0,0] --\u003e \"A1\"\n        in_out_map_mat = FINAL_OD.map {|f_od| in_out_map }.flatten.each_slice(12).to_a\n        in_out_map_mat.each {|arr| \n            if arr.length != 12\n                (12-arr.length).times do\n                    arr.push(-1)\n                end\n            end\n        }\n        if in_out_map_mat.length != 8\n            (8 - in_out_map_mat.length).times do\n                in_out_map_mat.push(Array.new(12) {-1})\n            end\n        end\n        \n        # Adding alpha numeric coordinates for controls \n        input_control_cults_coords = []\n        input_control_cults_coords.push(find_input_wt_cult_coord(collection=in_coll).map {|r, c| (ROWS[r] + COLS[c].to_s)}.first) # Creating 2 WT control cultures\n        input_control_cults_coords.push(find_input_wt_cult_coord(collection=in_coll).map {|r, c| (ROWS[r] + COLS[c].to_s)}.first)\n        gfp_control_coord = 'H9'\n        input_control_cults_coords.push(gfp_control_coord)\n        # input_control_cults_coords.each {|control_coord| in_out_map_mat[in_out_map_mat.length - 1].push(control_coord)}\n        # in_out_map_mat.push(input_control_cults_coords)\n        in_out_map_mat[7][6] = input_control_cults_coords[0]\n        in_out_map_mat[7][7] = input_control_cults_coords[1]\n        in_out_map_mat[7][8] = input_control_cults_coords[2]\n        display_coords = out_coll.get_non_empty.select {|r,c| !out_coll.matrix[r][c].nil? }.each_slice(in_out_map.select{|coord| !coord.include? \"H\"}.length).to_a\n        \n        # Diluting cultures 1:10 before transfering\n        show do\n            title \"Dilute Cultures in Item #{in_coll}\"\n            separator\n            check \"Perform a 1:10 dilution on cultures\"\n            bullet \"10ul of culture to 90ul of media\"\n        end\n        if debug\n            show do\n                title \"Debugging\"\n                note \"out_coll_#{out_coll}\"\n                note \"display_coords_#{display_coords}\"\n                note \"in_out_map_mat_#{in_out_map_mat}\"# ***\n                note \"cult_vol_mat_#{cult_vol_mat}\"\n            end\n        end\n\n        display_coords.each do |rc_list|\n            show do\n                title \"Innoculating New 96 Deep Well Plate #{out_coll}\"\n                separator\n                bullet \"The coordinates correspond to wells from 96 Flat Bottom Plate \u003cb\u003e#{in_coll.id}\u003c/b\u003e.\"\n                note \"Follow the table below to inoculate the filled 96 Deep Well Plate with the appropriate volume and culture:\"\n                table highlight_alpha_rc(out_coll, rc_list) {|r, c| \"#{in_out_map_mat[r][c] if in_out_map_mat[r][c]}\\n#{cult_vol_mat[r][c].round(1) if cult_vol_mat[r][c]}µl\"}\n            end\n        end\n        \n        group_by_collection = operations.map.group_by {|op| op.input(\"96 Well Flat Bottom\").collection}\n        growth_temperature = group_by_collection[in_coll].first.input(\"Growth Temperature (°C)\").val\n        Item.find(out_coll.id).associate('growth_temperature', growth_temperature)\n        # Move output plate (96DW Plate to incubator)\n        out_coll.location = \"#{growth_temperature}C Incubator Shaker @ 800 rpm\"\n        out_coll.save\n    ### IF USING THE SAME PLATE FOR MULTIPLE SYNCS THEN WHEN SHOULD WE DELETE INCOLLECTION\n        # in_coll.mark_as_deleted\n        release([out_coll], interactive: true)\n        \n    end    \n\n    \n    \n    # Based on the number of diltuions (Final ODs) create a new matrix with sample ids in the correct organization \n    #\n    # @params in_coll [collection] the input collection in order to obtain the sample id matrix\n    # @return out_samp_id_mat [2-D Array] matrix containing new sample id matrix; spread out input collection sample ids\n    def out_coll_samp_id_mat(in_coll)\n        if debug\n            in_coll = Collection.find(411551)\n        end\n        output_samp_ids = []\n        (FINAL_OD.length).times do \n            in_coll.matrix.each_with_index do |row, r_idx|\n                row.each_with_index do |well, c_idx|\n                    if !well.nil?\n                        if r_idx != 7\n                            well \u003e -1 ? output_samp_ids.push(well) : -1\n                        end\n                    end\n                end\n            end\n        end\n        # Filling in blank/empty wells with -1\n        out_samp_id_mat = output_samp_ids.each_slice(12).to_a\n        out_samp_id_mat.each {|row|\n            if row.length != 12\n                (12 - row.length).times do\n                    row.push(-1)\n                end\n            end\n        }\n        if out_samp_id_mat.length != 8\n            (8 - out_samp_id_mat.length).times do\n                out_samp_id_mat.push(Array.new(12) {-1})\n            end\n        end\n        return out_samp_id_mat\n    end\n\n\n\n    # Finds volume needed from input culture and the necessary media volume for the output culture/well\n    #\n    # @params row_od_aves [array] array of the average ODs by row\n    # @return cult_vols_ul [array] array of culture volumes found based on the average row ods\n    # @return media_vols_ul [array] array of media minus the culture volume\n    def ave_cult_media_vol(row_od_aves)\n        cult_vols_ul = []\n        media_vols_ul = []\n        FINAL_OD.each do |f_od|\n            c_vol = row_od_aves.map {|ave_od| ave_od == 0.0 ? 0.0 : ((f_od * FINAL_OUTPUT_VOL)/ave_od) * 10000.0} # 10,000 includes the 1:10 dilution\n            m_vol = c_vol.map {|vol| vol == 0.0 ? 0.0 : (1000.0 - vol).round()}\n            cult_vols_ul.push(c_vol)\n            media_vols_ul.push(m_vol)\n        end\n        return cult_vols_ul, media_vols_ul\n    end\n    \n    # Averages 2-D array across rows. Turns 2-D array into 1-D array of averages\n    #\n    # @param input_plate_ods [2-D Array] matrix containing the ODs of a 96 well plate measured on the BioTek Plate Reader\n    # @param \n    # @return row_od_aves [Array] array of averages across rows of the input matrix \n    def average_ods(input_cult_coords, input_plate_ods, bio_reps)\n        # slice = 6\n        average_ods = []\n        input_plate_ods.each_slice(bio_reps).to_a.map do |arr| \n            tot_od = 0.0\n            arr.each {|od| tot_od += od}\n            average_ods.push(tot_od/arr.length)\n        end\n        return average_ods\n    end\n    \n    # Creates a matrix based on the amount of row averages and number of wells measured\n    #\n    # @params input_plate_ods [Array] one dimensional array of non empty wells from input collection\n    # @params ave_arr [2-D Array] matrix created from ave vol calculated based on the ave od of each slice(6 wells)\n    # @return matrix [2-D Array] matrix with all volumes needed for display onto a 8x12 matrix\n    def matrix_mapping(input_plate_ods, ave_arr,bio_reps)\n        matrix = []\n        input_slices = input_plate_ods.each_slice(bio_reps).to_a\n        ave_arr.each do |arr|\n            input_slices.each_with_index do |slice, i|\n                slice.each {|well| matrix.push(arr[i])}\n            end\n        end\n        matrix = matrix.flatten\n        if matrix.length != 96\n            (96 - matrix.length).times do\n                matrix.push(-1)\n            end\n        end\n        return matrix.each_slice(12).to_a\n    end\n    \n    # Calculates the actual OD of each well based on the input well/cult OD and the average cult vol for that row\n    #\n    # @params input_plate_ods [array] 1 dim array with all the ODs that were measured from the input collection\n    # @params cult_vols_ul [2-D Array] a matrix of average culture volume needed to reach requested final OD\n    # @return actual_ods_mat [2-D Array] a matrix of the calculated actual OD in slices of 12 to fit the 96 well format\n    def actual_ods(input_plate_ods, cult_vols_ul, bio_reps)\n        actual_ods = []\n        well_ods_slices = input_plate_ods.each_slice(bio_reps).to_a\n        cult_vols_ul.each_with_index do |ave_cult_vol, i|\n            ave_cult_vol.each_with_index do |c_vol, ii|\n                well_ods_slices[ii].each {|w_od| actual_ods.push(((w_od * (c_vol/1000.0))/FINAL_OUTPUT_VOL).round(6))}\n            end\n        end\n        actual_ods_mat = actual_ods.each_slice(12).to_a\n        return actual_ods_mat\n    end\n    \n    # Averages 2-D array across rows. Turns 2-D array into 1-D array of averages\n    #\n    # @param input_plate_ods [2-D Array] matrix containing the ODs of a 96 well plate measured on the BioTek Plate Reader\n    # @param \n    # @return row_od_aves [Array] array of averages across rows of the input matrix \n    def average_ods(input_cult_coords, input_plate_ods, bio_reps)\n        # slice = 6\n        average_ods = []\n        input_plate_ods.each_slice(bio_reps).to_a.map do |arr| \n            tot_od = 0.0\n            arr.each {|od| tot_od += od}\n            average_ods.push(tot_od/arr.length)\n        end\n        return average_ods\n    end\n    \n    # given a r,c from one of the first 30 wells and an od level, figures out the location\n    # of the replicate on the output plate\n    def get_rc_out_from_rc_in_and_od_no(r,c,od, num_input_samples)\n        absolute_rc = r * 12 + c\n        if absolute_rc \u003e 30\n            raise \"rc in is not one of the first 30 samples\"\n        end\n        \n        adjusted_absolute = absolute_rc + od * num_input_samples\n        \n        r_out = adjusted_absolute / 12\n        c_out = adjusted_absolute % 12\n        return r_out, c_out\n    end\n\n    def get_bio_reps_from_outgrowth_plate(collection)\n        if debug\n            return 3\n        else\n            return Item.find(collection.id).get('bio_reps')\n        end\n    end\n\n\nend #Module\n\n"}},{"library":{"name":"Upload_PlateReader_Data","category":"YG_Harmonization","code_source":"# By: Eriberto Lopez\n# elopez3@uw.edu\n\n# This library contains functions that aid in uploading data that comes from yeast high throughput screening measurements\n# Ie: Plate reader measurements\nneeds 'Standard Libs/MatrixTools'\nneeds 'Standard Libs/AssociationManagement'\nmodule Upload_PlateReader_Data\n    require 'csv'\n    require 'open-uri'\n    include MatrixTools\n    include AssociationManagement\n    \n    # Takes in a csv upload file in a tabular format, extracts the information on it\n    # into a datamatrix object which is returned.\n    # Specificly tuned to the output file of the biotek plate reader.\n    #\n    # @param upload [Upload]  the object which can be resolved to calibration csv\n    # @return [WellMatrix]  a WellMatrix holding the measurement for each well\n    def extract_measurement_matrix_from_csv(upload)\n        url = upload.url\n        table = []\n        CSV.new(open(url)).each { |line| table.push(line) }\n        dm = WellMatrix.create_empty(96, -1) if table.size \u003e 25\n        dm = WellMatrix.create_empty(24, -1) if table.size \u003c= 25\n        table.each_with_index do |row, idx|\n          next if idx.zero?\n          well_coord = row[2]\n          next if well_coord.nil?\n          measurement = row[3].to_f\n          next if measurement.nil?\n          dm.set(well_coord, measurement)\n        end\n        dm\n    end\n    \n  # Returns the average OD measurement for different dilutions and well volumes.\n  # The plotted result of this method can be fit to a curve\n  # to be used for calibrating the plate reader. This is very specific to the\n  # Eriberto's calibration of the biotek plate reader.\n  #\n  # @param upload [Upload]  the object whihc can be resolved to calibration csv\n  # @return [Hash]  a hash containing averaged measurements for\n  #  \t\t\t\t\tevery concentration and volume tested\n    def get_calibration_data_hash(upload)\n        method = upload.name\n        dm = extract_measurement_matrix_from_csv(upload)\n        result = {}\n        data_by_conc = Hash.new { |h, key| h[key] = [0, 0] }\n\n        if method.include? 'gfp'\n            # show {note \"#{method}\"}\n            starting_concentration = 50.0#uM\n            # first 4 rows are serial dilutions\n            for i in 0...4\n              12.times do |j|\n                # each column is a 2x dilution of the previous, starting at 50uM\n                this_conc = starting_concentration / (2**j)\n                data = data_by_conc[this_conc]\n                data[0] += dm[i, j].to_f\n                data[1] += 1\n                data_by_conc[this_conc] = data\n              end\n            end\n            # add serial dilution averages to result hash\n            data_by_conc.each_key do |k,|\n              data = data_by_conc[k]\n              result[k] = data[0] / data[1]\n            end\n            return result\n        elsif method.include? 'od'\n            # row 5, 6 are lud dilutions and pure solution respectively\n            for i in 4...6\n                for j in 0...4\n                    data_by_conc[\"100_#{i}\"][0] += dm[i, j].to_f\n                    data_by_conc[\"100_#{i}\"][1] += 1\n                end\n                for j in 4...8\n                    data_by_conc[\"200_#{i}\"][0] += dm[i, j].to_f\n                    data_by_conc[\"200_#{i}\"][1] += 1\n                end\n                for j in 8...12\n                    data_by_conc[\"300_#{i}\"][0] += dm[i, j].to_f\n                    data_by_conc[\"300_#{i}\"][1] += 1\n                end\n            end\n            # add lud averages to result hash\n            for i in 1..3\n              lud_avg = data_by_conc[\"#{i}00_4\"][0] / data_by_conc[\"#{i}00_4\"][1]\n              sol_avg = data_by_conc[\"#{i}00_5\"][0] / data_by_conc[\"#{i}00_5\"][1]\n              result[\"lud#{i}00\"] = (lud_avg - sol_avg).round(5) # Returns blanked averages\n            end\n        end\n        result\n    end\n\n    # Provides a upload button in a showblock in order to upload a single file\n    #\n    # @params upload_filename [string] can be the name of the file that you want tech to upload\n    # @return up_show [hash] is the upload hash created in the upload show block\n    # @return up_sym [symbol] is the symbol created in upload show block that will be used to access upload\n    def upload_show(upload_filename)\n        upload_var = \"file\"\n        up_sym = upload_var.to_sym\n        up_show = show do\n            title \"Upload Your Measurements\"\n            note \"Select and Upload: #{upload_filename}\"\n            upload var: \"#{upload_var}\"\n        end\n        return up_show, up_sym\n    end\n    \n    # Retrieves the upload object from upload show block\n    #\n    # @params up_show [hash] is the hash that is created in the upload show block\n    # @params up_sym [symbol] is the symbol created in the upload show block and used to access file uploaded\n    # @return upload [upload_object] is the file that was uploaded in the upload show block\n    def find_upload_from_show(up_show, up_sym)\n        # Makes a query to find the uploaded file by its default :id\n        upload = up_show[up_sym].map {|up_hash| Upload.find(up_hash[:id])}.shift \n        return upload\n    end\n    \n    # Associates an upload to an item - DEPRCIATED\n    # #\n    # # @params collection [collection obj] can be the collection that you wish to associate upload to\n    # # @params upload [upload_obj] the file that you wish to associate to item\n    # # @params key [string] the key to the association it will also appear as description when looking at item\n    # def associate_to_item(collection, upload, key)\n    #     Item.find(collection.id).associate key.to_sym, \"item_#{collection.id}\", upload\n    # end\n    # Associates an upload to an item\n    #\n    # @params in_obj [obj] can be the collection that you wish to associate upload to\n    # @params upload [upload_obj] the file that you wish to associate to item\n    # @params key [string] the key to the association it will also appear as description when looking at item\n    def associate_to_item(in_obj, key, upload)\n        item_assoc = AssociationMap.new(in_obj)\n        item_assoc.put(key.to_sym, upload)\n        item_assoc.save\n    end\n\n    \n    # Associates an upload to the plan that it was uploaded in - Still needed for YG_Harmonization calibration associations\n    #\n    # @params upload [upload_obj] the file that you wish to associate to plan\n    # @params key [string] the key to the association it will also appear as description when looking at item\n    def associate_to_plan(upload, key)\n        plan = operations.map {|op| op.plan}.first\n        plan.associate key.to_sym, \"plan_#{plan.id}\", upload\n    end    \n    # Associates an upload to the plans that it was uploaded in\n    #\n    # @params data [obj] the thing that you wish to associate to plan\n    # @params key [string] the key to the association it will also appear as description when looking at item\n    def associate_to_plans(key, data) \n        # iterate over ops, find all unique plans, associate to each plan, ensure copying\n        plans = operations.map { |op| op.plan }.uniq\n        plans.each do |plan|\n            plan_associations = AssociationMap.new(plan)\n            plan_associations.put(key.to_sym, data)\n            plan_associations.save\n        end\n    end    \n    \n    # Opens file using its url and stores it line by line in a matrix\n    #\n    # @params upload [upload_obj] the file that you wish to read from\n    # @return matrix [2D-Array] is the array of arrays of the rows read from file, if csv\n    def read_url(upload)\n        url = upload.url\n        matrix = []\n        CSV.new(open(url)).each {|line| matrix.push(line)}\n        # open(url).each {|line| matrix.push(line.split(',')}\n        return matrix\n    end\n\n    \n    # Takes csv matrix and formats data for OD measurements - Biotek Plate reader\n    #\n    # @params matrix [2D-Array] can be array of arrays containing od measurements \n    # @return hash [hash] is hash created from matrix parameter\n    def matrix_to_hash(matrix)\n        hash = Hash.new(0)\n        cols = matrix.shift.select {|col| col != nil}\n        rows = []\n        data = []\n        ods = matrix.map do |arr|\n            rows.push(arr.shift) # first index is row letter\n            arr.pop() # Strips off last index\n            arr.map! {|str| str.to_f} # converts strings to float to include dilution factor\n            data.push(arr)\n            arr.map {|od| od} # Good place to include dilution factor\n        end\n        hash[\"cols\"] = cols\n        hash[\"rows\"] = rows\n        hash[\"data\"] = data\n        # hash[\"optical_density\"] = ods\n        return hash\n    end\n\n    \n    # Reads uploaded file and associates data to a given item/collection\n    #\n    # @params upload [upload obj] upload (csv) that is going to be read and processed\n    # @params collection [collection obj] collection that the data will be associated to\n    # @params method [string] the type of measurement that was taken (od or gfp)\n    # @params timepoint [integer] the number of hours that data was collected at\n    def associate_PlateReader_Data(upload, collection, method, timepoint)\n        up_name = upload.name.downcase\n        up_ext = up_name.split('.')[1]\n        if up_ext.downcase == 'csv'\n            # If calibration measurement will be associated with item and plan\n            collection_associations = AssociationMap.new(collection)\n            if up_name.include? 'cal'\n                key = method == 'cal_gfp' ? 'cal_fluorescence' : 'cal_optical_density'\n                \n                cal_hash = get_calibration_data_hash(upload) # from BiotekPlateReader Lib\n                data_hash = Hash.new(0)\n                if method == 'cal_gfp'\n                    # Fluorescence std curve \u0026 r-sq value\n                    slope, yint, x_arr, y_arr = gfp_standard_curve(cal_hash)\n                    r_sq = r_squared_val(slope, yint, x_arr, y_arr)\n                    trendline = \"y = #{slope}x + #{yint}  (R^2 = #{r_sq})\"\n                    # Associating flour calibration data hash\n                    \n                    data_hash['uM_to_data'] = cal_hash\n                    collection_associations.put(key, data_hash)\n                    # ie: 'cal_fluorescence' : {'uM_to_data'=\u003e{50=\u003e2400,25=\u003e1234...}}\n                    collection_associations.put('Fluorescence Standard Curve', trendline)\n                    associate_to_plans('Fluorescence_Standard_Curve', trendline)\n                else\n                    correction_val_hash = ludox_correction_factors(cal_hash)\n                    data_hash['vol_to_correction_factor'] = correction_val_hash\n                    collection_associations.put(key, data_hash) # ie: 'cal_od'=\u003e{'vol_to_correction_factor'=\u003e{\"100\"=\u003e1.88,\"200\"=\u003e0.955}}\n                    associate_to_plans('vol_to_correction_factor', correction_val_hash)\n                end\n                \n            else\n                # matrix = read_url(upload)\n                matrix = (extract_measurement_matrix_from_csv(upload)).to_a # Uses BiotekPlateReaderCalibration/PlateReaderMethods\n                # hash = matrix_to_hash(matrix) # Upload_Data Lib - May change if I change data format\n                log_info 'csv matrix', matrix\n                # take hash and slice up to associate to input collections - that way matrix always gets formatted to the same dimensions as in_collection\n                in_cols = collection.object_type.columns\n                in_rows = collection.object_type.rows\n                \n                # 'data' - known beforehand, created in matrix_to_OD_hash(matrix)\n                # slices = hash['data'].flatten.each_slice(in_cols).map {|slice| slice} # 2-D Array with similar dims as collection\n                slices = matrix.flatten.each_slice(in_cols).map {|slice| slice} # 2-D Array with similar dims as collection\n                log_info 'sliced up csv', slices\n                \n                #### left off here attempting to create hashes for GFP or optical density at differnet timepoints if necessary\n                key = method == 'od' ? 'optical_density': 'gfp_fluorescence'\n                data_hash = collection_associations.get(key)\n                log_info slices.shift(in_rows)\n                if data_hash.nil? \n                    data_hash = Hash.new(0)\n                    data_hash[\"#{timepoint}_hr\"] = slices.shift(in_rows)\n                    collection_associations.put(key, data_hash)\n                else\n                    data_hash[\"#{timepoint}_hr\"] = slices.shift(in_rows)\n                    collection_associations.put(key, data_hash)\n                end\n            end\n            collection_associations.save\n        end\n        # should produce ie: 'optical_density': {'16h_od'=\u003e[[][][][]...[]]}\n    end\n\n    \n    # For associating a matrix to an item\n    #\n    # Associatition skem: key:{ desc:[mat] }\n    # @params item [object] item object that data will be associated to\n    # @params key [string] key to the data hash associated to the item \n    # @params desc [string] describes the certain matrix data that it is pair with in the data hash\n    # @params mat [2D-Array] is the matrix of data being associated\n    def associate_mat_to_item(item, key, desc, mat)\n        hash = Hash.new(0)\n        data_hsh = hash[desc] = mat\n        item.associate(key, data_hsh)\n    end\n        # This fuction uses a reference od600 measurement to calculate the correction factor for different vols (100ul, 200, 300)\n    # \n    # @params hash [hash] is the hash of averaged blanked LUDOX samples at different volumes\n    # \n    # @returns correction_val_hash [hash] is the hash containing the correction factor for the optical density (600nm) for this experiment\n    def ludox_correction_factors(hash)\n        ref_od600 = 0.0425 #Taken from iGEM protocol - is the ref val of another spectrophotometer\n        # ref/corrected vals\n        correction_val_hash = Hash.new(0)\n        hash.each do |vol, ave|\n            correction_val_hash[vol[3..6]] = (ref_od600/ave).round(4)\n        end\n        return correction_val_hash\n    end\n  \n    # This function creates a standard curve from the flourocein calibration plate\n    #\n    # @params coordinates [hash or 2D-Array] can be a hash or [[x,y],..] where x is known concentration \u0026 y is measurement of flouroscence\n    #\n    # @returns slope [float] float representing the slope of the regressional line\n    # @returns yint [float] float representing where the line intercepts the y-axis\n    # @returns x_arr [Array] a 1D array for all x coords\n    # @returns y_arr [Array] a 1D arrya for all y coords\n    def gfp_standard_curve(coordinates)\n        # Calculating Std Curve for GFP\n        num_of_pts = 0\n        a = 0\n        x_sum = 0\n        y_sum = 0\n        x_sq_sum = 0\n        x_arr = []\n        y_arr = []\n        coordinates.each do |x, y|\n            if x \u003c 25 # Above 25uM is out of linear range of our instrument\n                a += (x * y)\n                x_sum += x\n                x_sq_sum += (x**2)\n                y_sum += y\n                x_arr.push(x)\n                y_arr.push(y)\n                num_of_pts += 1\n            end\n        end\n        a *= num_of_pts\n        b = x_sum * y_sum\n        c = num_of_pts * x_sq_sum\n        d = x_sum**2\n        slope = (a - b)/(c - d)\n        f = slope * (x_sum)\n        yint = (y_sum - f)/num_of_pts\n        # show{note \"y = #{(slope).round(2)}x + #{(yint).round(2)}\"}\n        return (slope).round(3), (yint).round(3), x_arr, y_arr\n    end\n    \n    # This function calculates how much deviation points are from a regressional line - R-squared Value \n    # The closer it is to 1 or -1 the less deviation theres is\n    #\n    # @params slope [float] float representing the slope of the regressional line\n    # @params yint [float] float representing where the line intercepts the y-axis\n    # @params x_arr [Array] a 1D array for all x coords\n    # @params y_arr [Array] a 1D arrya for all y coords\n    #\n    # @returns rsq_val [float] float representing the R-squared Value\n    def r_squared_val(slope, yint, x_arr, y_arr)\n        y_mean = y_arr.sum/y_arr.length.to_f\n        # Deviation of y coordinate from the y_mean\n        y_mean_devs = y_arr.map {|y| (y - y_mean)**2}\n        dist_mean = y_mean_devs.sum # the sq distance from the mean\n        # Finding y-hat using regression line\n        y_estimate_vals = x_arr.map {|x| (slope * x) + yint }\n        # Deviation of y-hat values from the y_mean\n        y_estimate_dev = y_estimate_vals.map {|y| (y - y_mean)**2}\n        dist_regres = y_estimate_dev.sum # the sq distance from regress. line\n        rsq_val = (dist_regres/dist_mean).round(4)\n        return rsq_val\n    end\n\nend # Module"}},{"library":{"name":"YG_Controls","category":"YG_Harmonization","code_source":"# By: Eriberto Lopez\n# elopez3@uw.edu\n# Updated: 08/15/18\n# This library is to help with creating additional controls to the YG_Harmonization workflow\n\nneeds 'Standard Libs/AssociationManagement'\n\nmodule YG_Controls\n    include AssociationManagement\n    include PartProvenance\n    \n    def creating_neg_pos_wt_staining_control(in_collection, out_collection, output_cult_dest, cult_vol_mat, media_vol_mat, input_cult_coords, samp_id=22544) #Sync by OD\n        if debug\n            samp_id = 22544 # WT 22544 is not in Nursery \n        end\n        # Finding where WT is on the input collection in order to copy cult and media vol for synchronization of WT controls\n        input_wt_cult_coord = find_input_wt_cult_coord(collection=in_collection)\n        # log_info 'input_wt_cult_coord creating control', input_wt_cult_coord\n        \n        # Found the coordinate in which wt is in now copy the media vol and the culture vol\n        neg_pos_wt_cult_coord_destination = ['H7', 'H8'] # Where I want control cults to be in the output plate\n        neg_pos_wt_cult_coord_destination = find_rc_from_alpha_coord(alpha_coord=neg_pos_wt_cult_coord_destination)\n        neg_pos_stn_wt_cult_vol = input_wt_cult_coord.map {|r,c| cult_vol_mat[r][c]}.first\n        neg_pos_stn_wt_media_vol = input_wt_cult_coord.map {|r,c| media_vol_mat[r][c]}.first\n        neg_pos_wt_cult_coord_destination.each {|r,c|\n            cult_vol_mat[r][c] = neg_pos_stn_wt_cult_vol\n            media_vol_mat[r][c] = neg_pos_stn_wt_media_vol\n            input_cult_coords.push([r, c])\n            out_coll_matrix = out_collection.matrix \n            out_coll_matrix[r][c] = samp_id # sample_id Diploid WT\n            out_collection.matrix = out_coll_matrix\n            out_collection.save\n        }\n        \n        return input_cult_coords, cult_vol_mat, media_vol_mat\n    end\n    \n    \n    def creating_pos_gfp_control(out_collection, input_plate_ods, final_output_vol, cult_vol_mat, media_vol_mat, input_cult_coords, samp_id=6390) # Sync by OD\n        gfp_input_cult_coord = 'H9' # gfp culture is in the same place that it will be in the deep well experimental plate\n        gfp_input_cult_coord_destination = find_rc_from_alpha_coord(alpha_coord=gfp_input_cult_coord)\n        gfp_input_cult_vol, gfp_input_media_vol = sync_gfp_control(gfp_input_cult_coord=gfp_input_cult_coord, gfp_output_cult_coord=gfp_input_cult_coord, input_plate_ods, final_output_vol) #YG_Controls\n        log_info 'gfp_input_cult_vol', gfp_input_cult_vol, 'gfp_input_media_vol',gfp_input_media_vol\n        gfp_input_cult_coord_destination.each {|r,c|\n            cult_vol_mat[r][c] = gfp_input_cult_vol\n            media_vol_mat[r][c] = gfp_input_media_vol\n            input_cult_coords.push([r, c])\n            out_coll_matrix = out_collection.matrix \n            out_coll_matrix[r][c] = samp_id # sample_id NOR00 1.0\n            out_collection.matrix = out_coll_matrix\n            out_collection.save\n        }\n        return input_cult_coords, cult_vol_mat, media_vol_mat\n    end\n    \n    # Will find where in a collection diploid WT is located and return [[r,c]]\n    def find_input_wt_cult_coord(collection)\n        wt_cult_coord = []\n        collection.matrix.each_with_index.map {|row, r_idx|\n            row.each_with_index.map {|col, c_idx|\n                wt_sample_id = []\n                if debug\n                    wt_sample_id = [1, 30, 22544, 22801]\n                else\n                    wt_sample_id = [30, 22544, 22801]\n                end\n                \n                # Once wt sample_id is found in the collection return [[r,c]]\n                if wt_sample_id.include? col\n                    wt_cult_coord.push([r_idx, c_idx])\n                    break\n                end\n            }\n        }\n        return wt_cult_coord\n    end\n\n    \n    # Will add a positive gfp colony (NOR00) to a desired well in a collection\n    #\n    # @params collection [collection obj] the collection to which the gfp control will be added to\n    # @params well [string] the alpha numeric coordinate that the gfp colony will be added to\n    # @returns need_to_create_new_control_plate[:make_new_plate] [boolean] will return true or false based on user input\n    def adding_positive_gfp_control(collection, well='H9')\n        strain_sample_id = 6390 # NOR_00 1.0\n        obj_type = \"Yeast Plate\"\n        # Find the plate created for the gfp positive control\n        positive_gfp_control_plate = find(:item, { sample: { id: strain_sample_id }, object_type: { name: obj_type } } ).select {|item| \n            item.get('YG_Control') == 'positive_gfp'\n        }.first # Key: YG_Control, Value: 'positive_gfp' - previously associated value to sample and item\n        \n        take [positive_gfp_control_plate], interactive: true\n        \n        display_rc_list = find_rc_from_alpha_coord(well)\n        show do \n            title \"Adding Positive GFP Control\"\n            separator\n            note \"To 96 Flat Bottom Plate \u003cb\u003e#{collection.id}\u003c/b\u003e:\"\n            bullet \"Fill \u003cb\u003e#{well}\u003c/b\u003e with 200µl of liquid SC media\"\n            bullet \"Pick colony from Yeast Plate \u003cb\u003e#{positive_gfp_control_plate.id}\u003c/b\u003e \u0026 resuspend in the well highlighted below\"\n            table highlight_alpha_rc(collection, display_rc_list) {|r,c| \"#{positive_gfp_control_plate.id}\"}\n            check \"\u003cb\u003eFinally, place clear lid on top and tape shut before placing it on the plate shaker.\u003c/b\u003e\"\n        end\n        \n        # Associate provenance data between control plate and collection\n        control_plate_associations = AssociationMap.new(positive_gfp_control_plate)\n        \n        display_rc_list.each do |r, c|\n            # Add control strain to collection\n            collection_sample_matrix = collection.matrix\n            collection_sample_matrix[r][c] = strain_sample_id\n            collection.matrix = collection_sample_matrix \n\n            part = collection.part(r,c)\n            part_associations = AssociationMap.new(part)\n            add_provenance({\n                           from: positive_gfp_control_plate,\n                           from_map: control_plate_associations,\n                           to: part,\n                           to_map: part_associations,\n                           additional_relation_data: { source_colony: 1, process: \"resuspension\" }\n                         })\n\n            # Associate additional data to this part\n            part_associations.put('control', \"positive_gfp\")\n            part_associations.save\n            # Add control strain to collection\n            # collection_sample_matrix = collection.matrix\n            # collection_sample_matrix[r][c] = strain_sample_id\n            # collection.matrix = collection_sample_matrix \n        end\n        control_plate_associations.save\n        \n        need_to_create_new_control_plate = show do\n            title \"Checking Control Plate #{positive_gfp_control_plate}\" \n            separator\n            select [\"Yes\", \"No\"], var: \"make_new_plate\" , label: \"Are there colonies left to be picked?\" , default: 1\n        end\n        \n        release [positive_gfp_control_plate], interactive: true\n        return need_to_create_new_control_plate[:make_new_plate].to_s\n    end\n    \n    \n    # Finds where an alpha_coordinate is in a 96 Well plate\n    #\n    # @params alpha_coord [array or string] can be a single alpha_coordinate or a list of alpha_coordinate strings ie: 'A1' or ['A1','H7']\n    # @return rc_list [Array] a list of [r,c] coordinates that describe where the alpha_coord(s) are in a 96 well matrix\n    def find_rc_from_alpha_coord(alpha_coord)\n        # look for where alpha coord is 2-D array coord\n        coordinates_96 = ('A'..'H').to_a.map {|row| (1..12).to_a.map {|col| row + col.to_s}} \n        rc_list = []\n        if alpha_coord.instance_of? Array\n            # alpha_coord = alpha_coord.map {|a| a.upcase}\n            alpha_coord.each {|a_coord|\n                coordinates_96.map.each_with_index { |row, r_idx| row.each_index.select {|col| row[col] == a_coord.upcase}.each { |c_idx| rc_list.push([r_idx, c_idx]) } } \n            }\n        else\n            coordinates_96.map.each_with_index { |row, r_idx| row.each_index.select {|col| row[col] == alpha_coord.upcase}.each { |c_idx| rc_list.push([r_idx, c_idx]) } }\n        end\n        return rc_list\n    end\n    \n    \n    def diluting_gfp_control(in_collection, out_collection, final_od=0.0003)\n        in_data_matrix = in_map.get_data_matrix\n        \n        in_data_matrix.each_with_index do |row, r_idx|\n            row.each_with_index do |part_data, c_idx|\n                if !part_data.nil?\n                    if part_data['control'] == 'positive_gfp'\n                        # record relation between input and output parts, well position is the same\n                        # for this transfer\n                        from_part = in_collection.part(r_idx, c_idx)\n                        to_part = out_collection.part(r_idx, c_idx)\n                        in_map = AssociationMap.new(from_part)\n                        out_map = AssociationMap.new(to_part)\n                        add_provenance({\n                                         from: from_part,\n                                         from_map: in_map,\n                                         to: to_part,\n                                         to_map: out_map,\n                                         additional_relation_data: { process: \"dilution\" }\n                                       })\n            \n                        # Associate additional data to this part on output collection\n                        out_map.put('control', \"positive_gfp\")\n                        out_map.put('od600', \"#{final_od}\")\n                        in_map.save\n                        out_map.save\n\n                        # manually populate sample_id matrix of output collection\n                        out_collection.matrix[r_idx][c_idx] = in_collection.matrix[r_idx][c_idx]\n                        out_collection.save\n                    end\n                end\n            end\n        end\n    end\n\n    def sync_gfp_control(gfp_input_cult_coord, gfp_output_cult_coord, input_plate_ods, final_output_vol)\n        gfp_input_cult_coord = find_rc_from_alpha_coord(alpha_coord=gfp_input_cult_coord)\n        gfp_input_cult_od = gfp_input_cult_coord.map {|r,c| input_plate_ods[r][c]}.first * 10 #dilution 1:10\n        gfp_input_cult_vol = ((0.0003*final_output_vol)/gfp_input_cult_od) * 1000 # converting to ul\n        gfp_input_media_vol = (1000.0 - gfp_input_cult_vol).round(2)\n        return gfp_input_cult_vol, gfp_input_media_vol\n    end\n\n    \nend # Module\n"}},{"library":{"name":"YG_Measure_OD_GFP","category":"YG_Harmonization","code_source":"# By: Eriberto Lopez\n# elopez3@uw.edu\n# 10/01/18\n\nmodule YG_Measure_OD_GFP\n    \n    def transfer_cultures(in_item, out_item) \n        \n        if debug\n            in_item = Item.find(276614) # Contains new part_associations 100118\n        end\n        \n        in_collection = Collection.find(in_item.id)\n        out_collection = Collection.find(out_item.id)\n        \n        rc_list = in_collection.get_non_empty\n        \n        vol_display_matrix = get_vol_transfer_matrix(in_collection)\n        log_info 'vol_display_matrix', vol_display_matrix\n        show do\n           title \"Transfer Culture Aliquots to #{out_item.object_type.name} for Plate Reader\" \n           separator\n           check \"Grab a clean \u003cb\u003e#{out_item.object_type.name}\u003c/b\u003e.\"\n           check \"Label the #{out_item.object_type.name} =\u003e \u003cb\u003e#{out_item.id}\u003c/b\u003e.\"\n           check \"Use a multi-channel pipettor to transfer the correct volume from \u003cb\u003e#{in_item.id}\u003c/b\u003e to the \u003cb\u003e#{out_item.object_type.name}\u003c/b\u003e.\"\n           note \"\u003cb\u003eFollow the table below to transfer the correct volume:\u003c/b\u003e\"\n           table highlight_alpha_rc(in_item, rc_list) {|r,c| \"#{vol_display_matrix[r][c]}µl\"}\n        end\n        positive_sytox_rc = get_pos_sytox_rc(in_collection)\n        show do \n            title \"Adding Ethanol to Positive SYTOX Control\"\n            separator\n            check \"Get #{150*positive_sytox_rc.length}µl of 100% EtOH\"\n            bullet \"Mix throughly by pipetting\"\n            note \"\u003cb\u003eFollow the table below to add 150ul of EtOH to the correct well\u003c/b\u003e\"\n            table highlight_alpha_rc(in_item, positive_sytox_rc){|r,c| \"150µl\"}\n        end\n        \n        # Ensure that collection sample matricies get transferred\n        in_coll_matrix = in_collection.matrix\n        out_collection.matrix = in_coll_matrix\n        out_collection.save\n    end\n    \n    def get_vol_transfer_matrix(in_collection)\n        vol_display_matrix = Array.new(in_collection.object_type.rows) { Array.new(in_collection.object_type.columns) {-1}}\n        rc_list = in_collection.get_non_empty\n        rc_list.each {|r,c|\n            control_check = in_collection.get_part_data(:control, r, c)\n            if control_check == 'negative_sytox'\n                vol_display_matrix[r][c] = 150\n            else\n                vol_display_matrix[r][c] = 300\n            end\n            \n        }\n        return vol_display_matrix\n        # Old part_data association matrix - 100118\n        # vol_display_matrix = input_part_data_matrix.each_with_index.map {|row, r_idx| \n        #     row.each_with_index.map {|part_data_obj, c_idx|\n        #         # ie: part_data_obj =\u003e {\"source\"=\u003e[{\"id\"=\u003e291209, \"row\"=\u003e0, \"column\"=\u003e0, \"process\"=\u003e\"dilution\"}], \"od600\"=\u003e0.0003}\n        #         obj_keys = part_data_obj.keys\n        #         if !obj_keys.empty?\n        #             if obj_keys.include? 'control'\n        #                 (part_data_obj[:control] == 'negative_sytox') ? trans_vol = 150 : trans_vol = 300\n        #             else\n        #                 trans_vol = 300\n        #             end\n        #         else\n        #             trans_vol = -1\n        #         end\n        #         trans_vol\n        #     }\n        # }\n    end\n    def get_pos_sytox_rc(in_collection)\n        positive_sytox_rc = []\n        rc_list = in_collection.get_non_empty\n        rc_list.each {|r,c|\n            control_check = in_collection.get_part_data(:control, r, c)\n            if control_check == 'negative_sytox'\n                positive_sytox_rc.push([r,c])\n            end\n        }\n        # Old part_data association matrix - 100118\n        # vol_display_matrix = input_part_data_matrix.each_with_index.map {|row, r_idx| \n        #     row.each_with_index.map {|part_data_obj, c_idx|\n        #         # ie: part_data_obj =\u003e {\"source\"=\u003e[{\"id\"=\u003e291209, \"row\"=\u003e0, \"column\"=\u003e0, \"process\"=\u003e\"dilution\"}], \"od600\"=\u003e0.0003}\n        #         obj_keys = part_data_obj.keys\n        #         if !obj_keys.empty?\n        #             if obj_keys.include? 'control'\n        #                 (part_data_obj[:control] == 'positive_sytox') ? positive_sytox_rc.push([r_idx, c_idx]) : nil\n        #             end\n        #         end\n        #     }\n        # }\n        return positive_sytox_rc\n    end\n    \n    def get_timepoint(op, tpoint_param)\n        return op.input(tpoint_param).val.to_i\n    end\n    \n    def get_media_type(in_item)\n        media = in_item.get('type_of_media')\n        media = media.nil? ? 'SC' : media\n        return media\n    end\n\n\nend # Module YG_Measure_OD_GFP"}}]}